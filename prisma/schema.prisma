generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SUPER_ADMIN
  MODERATOR
  COMPANY_ADMIN
  COMPANY_USER
}

enum CommonStatus {
  ACTIVE
  INACTIVE
  PENDING
  SUSPENDED
}

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

model User {
  id       String @id @default(uuid())
  username String @unique
  email    String @unique
  password String

  phone   String? // optional
  name    String? // optional
  address String? // optional

  userRole UserRole     @default(COMPANY_USER)
  status   CommonStatus @default(ACTIVE)

  companyId String? // optional, references Company.id
  company   Company? @relation(fields: [companyId], references: [id])

  auditLogs AuditLog[] @relation("UserAuditLogs")

  // Self-referential auditing relations
  createdById  String? // FK -> User.id
  createdBy    User?   @relation("UserCreatedBy", fields: [createdById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  createdUsers User[]  @relation("UserCreatedBy")

  updatedById  String? // FK -> User.id
  updatedBy    User?   @relation("UserUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  updatedUsers User[]  @relation("UserUpdatedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-relations for auditing on other models
  companiesCreated      Company[]      @relation("CompanyCreatedBy")
  companiesUpdated      Company[]      @relation("CompanyUpdatedBy")
  accountsCreated       Account[]      @relation("AccountCreatedBy")
  accountsUpdated       Account[]      @relation("AccountUpdatedBy")
  journalEntriesCreated JournalEntry[] @relation("JournalEntryCreatedBy")
  journalEntriesUpdated JournalEntry[] @relation("JournalEntryUpdatedBy")
  journalLinesCreated   JournalLine[]  @relation("JournalLineCreatedBy")
  journalLinesUpdated   JournalLine[]  @relation("JournalLineUpdatedBy")

  @@index([companyId])
  @@index([status])
  @@index([createdById])
  @@index([updatedById])
}

model Company {
  id    String @id @default(uuid())
  name  String
  email String @unique

  description String? // optional
  address     String? // optional
  phone       String? // optional

  status CommonStatus @default(ACTIVE)

  users          User[]
  accounts       Account[]
  journalEntries JournalEntry[]

  // Auditing (references User)
  createdById String?
  createdBy   User?   @relation("CompanyCreatedBy", fields: [createdById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  updatedById String?
  updatedBy   User?   @relation("CompanyUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([createdById])
  @@index([updatedById])
}

model Account {
  id   String @id @default(uuid())
  name String

  accountType AccountType
  status      CommonStatus @default(ACTIVE)

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  journalLines JournalLine[]

  // Auditing (references User)
  createdById String?
  createdBy   User?   @relation("AccountCreatedBy", fields: [createdById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  updatedById String?
  updatedBy   User?   @relation("AccountUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, name]) // unique account name per company
  @@index([companyId])
  @@index([status])
  @@index([accountType])
  @@index([createdById])
  @@index([updatedById])
}

model JournalEntry {
  id   String   @id @default(uuid())
  date DateTime

  description String? // optional

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  journalLines JournalLine[]

  // Auditing (references User)
  createdById String?
  createdBy   User?   @relation("JournalEntryCreatedBy", fields: [createdById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  updatedById String?
  updatedBy   User?   @relation("JournalEntryUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([date])
  @@index([createdById])
  @@index([updatedById])
}

model JournalLine {
  id           String  @id @default(uuid())
  debitAmount  Float? // optional, one of debitAmount or creditAmount must be set
  creditAmount Float? // optional, one of debitAmount or creditAmount must be set
  description  String? // optional

  journalEntryId String
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  accountId      String
  account        Account      @relation(fields: [accountId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // Auditing (references User)
  createdById String?
  createdBy   User?   @relation("JournalLineCreatedBy", fields: [createdById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  updatedById String?
  updatedBy   User?   @relation("JournalLineUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // NOTE: Add a raw SQL migration with a CHECK constraint enforcing XOR of debitAmount/creditAmount
  // Example: ALTER TABLE "JournalLine" ADD CONSTRAINT journalline_debit_xor_credit CHECK (("debitAmount" IS NOT NULL AND "creditAmount" IS NULL) OR ("debitAmount" IS NULL AND "creditAmount" IS NOT NULL));

  @@index([journalEntryId])
  @@index([accountId])
  @@index([createdById])
}

model AuditLog {
  id       String  @id @default(uuid())
  action   String
  entity   String
  entityId String
  changes  String? // optional, JSON string of changes

  performedBy String? // optional, references User.id
  user        User?   @relation("UserAuditLogs", fields: [performedBy], references: [id], onDelete: SetNull, onUpdate: Cascade)

  performedAt DateTime @default(now())

  @@index([entity])
  @@index([entityId])
  @@index([performedBy])
}
